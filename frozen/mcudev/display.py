import mcudev.glcdfont as glcdfontimport machineimport stmimport timeimport micropythonimport gcfrom mcudev.fsmc import FSMC_Display_Zx as Display#from mcudev.fsmc import FSMC_SRAM as SRAM#from mcudev_fsmc import LCD_Zx_REG as LCD_REG ## Works slower with imported const, about 10%#from mcudev_fsmc import LCD_Zx_RAM as LCD_RAM ## Works slower with imported const, about 10%# VET6 - version#LCD_REG = const(0x60000000)#LCD_RAM = const(0x60080000)# ZGT6 = version#LCD_Zx_REG = const(0x6C000000)#LCD_Zx_RAM = const(0x6C000080) ## | 0x80 <- 16bit access | 0x40 <- 8bit access_LCD_REG = const(0x6C000000)_LCD_RAM = const(0x6C000080)class ILI9341_Fsmc():    def __init__(self):        self.board = Display()        self.board.init_fsmc_disp()        self.board.init_fsmc_ram()        #self.board = SRAM()        #self.board.init_fsmc_ram()        self.board = None        gc.collect()        self.init_display()        self.clear(0x0)    @micropython.native    def __divide(self, a, b) -> int:        return int(a / b)    @micropython.viper    def init_display(self):        _reg = ptr8(_LCD_REG)        _reg[0] = 0x01        #self.cmd(0x01, bytearray(0))  # SOFTWARE RESET        time.sleep_ms(125)        self.cmd(0xCB, bytearray([0x39, 0x2C, 0x00, 0x34, 0x02]))  # POWER CONTROL A        self.cmd(0xCF, bytearray([0x00, 0xC1, 0x30]))  # POWER CONTROL B        self.cmd(0xE8, bytearray([0x85, 0x00, 0x78]))  # DRIVER TIMING CONTROL A        self.cmd(0xEA, bytearray([0x00, 0x00]))  # DRIVER TIMING CONTROL B        self.cmd(0xED, bytearray([0x64, 0x03, 0x12, 0x81]))  # POWER ON SEQUENCE CONTROL        self.cmd(0xF7, bytearray([0x20]))  # PUMP RATIO CONTROL        self.cmd(0xC0, bytearray([0x23]))  # POWER CONTROL,VRH[5:0]        self.cmd(0xC1, bytearray([0x10]))  # POWER CONTROL,SAP[2:0]BT[3:0]        self.cmd(0xC5, bytearray([0x3E, 0x28]))  # VCM CONTROL        self.cmd(0xC7, bytearray([0x86]))  # VCM CONTROL 2        self.cmd(0x36, bytearray([0x48]))  # MEMORY ACCESS CONTROL        self.cmd(0x3A, bytearray([0x55]))  # PIXEL FORMAT 16bit        self.cmd(0xB1, bytearray([0x00, 0x18]))  # FRAME RATIO CONTROL, STANDARD RGB COLOR        self.cmd(0xB6, bytearray([0x08, 0x82, 0x27]))  # DISPLAY FUNCTION CONTROL        self.cmd(0x11, bytearray(0))  # EXIT SLEEP (and wait 120ms)        time.sleep_ms(125)        _reg[0] = 0x29        #self.cmd(0x29, bytearray(0))  # TURN ON DISPLAY        self.cmd(0x36, bytearray([0x08]))  # setup Memory Access Control    @micropython.viper    def cmd(self, command: int, values):        _reg = ptr8(_LCD_REG)        _ram = ptr8(_LCD_RAM)        _reg[0] = command        _p_data = ptr8(values)        for i in range(int(len(values))):            _ram[0] = _p_data[i]    @micropython.viper    def draw_pixel(self, x: int, y: int, c: int):        _reg = ptr16(_LCD_REG)        #_par = ptr8(_LCD_RAM)        _ram = ptr16(_LCD_RAM)        #xx  = (x & 0xFF00)>> 8        #xx |= (x & 0xff)<<8        #yy  = (y >> 8) & 0xFF        #yy |= (y & 0xff)<<8        _reg[0] = 0x2A        # start x        _ram[0] = x >> 8         _ram[0] = x        # end x        _ram[0] = x >> 8         _ram[0] = x                _reg[0] = 0x2B        # start y        _ram[0] = y >> 8        _ram[0] = y        # end y        _ram[0] = y >> 8        _ram[0] = y                _reg[0] = 0x2C        #ram[0] = c >> 8        _ram[0] = c            """    @micropython.viper    def draw_pixel8(self, x: int, y: int, c: int):        reg = ptr8(_LCD_REG)        ram = ptr8(_LCD_RAM)        reg[0] = 0x2A        ram[0] = x >> 8        ram[0] = x        ram[0] = x >> 8        ram[0] = x        reg[0] = 0x2B        ram[0] = y >> 8        ram[0] = y        ram[0] = y >> 8        ram[0] = y        reg[0] = 0x2C        ram[0] = c >> 8        ram[0] = c    """    @micropython.viper    def draw_raw(self, x1: int, y1: int, x2: int, y2: int, data):        _reg = ptr8(_LCD_REG)        _ram = ptr16(_LCD_RAM)        _p_data = ptr16(data)        _reg[0] = 0x2A        _ram[0] = x1 >> 8        _ram[0] = x1        _ram[0] = x2 >> 8        _ram[0] = x2        _reg[0] = 0x2B        _ram[0] = y1 >> 8        _ram[0] = y1        _ram[0] = y2 >> 8        _ram[0] = y2        _reg[0] = 0x2C        for i in range((x2-x1+1) * (y2-y1+1)):            ram16[0] = _p_data[i]    @micropython.viper    def draw_rect(self, x1: int, y1: int, x2: int, y2: int, c: int):        _reg = ptr8(_LCD_REG)        #_par = ptr8(_LCD_RAM)        _ram = ptr16(_LCD_RAM)        _reg[0] = 0x2A        _ram[0] = x1 >> 8        _ram[0] = x1        _ram[0] = x2 >> 8        _ram[0] = x2        _reg[0] = 0x2B        _ram[0] = y1 >> 8        _ram[0] = y1        _ram[0] = y2 >> 8        _ram[0] = y2        _reg[0] = 0x2C        for i in range((x2-x1+1) * (y2-y1+1)):            #ram[0] = c >> 8            _ram[0] = c    @micropython.viper    def draw_line(self, x1: int, y1: int, x2: int, y2: int, c: int):        if x1 == x2:            if y2 > y1:                self.draw_rect(x1, y1, x2+1, y2, c)            else:                self.draw_rect(x1, y2, x2+1, y1, c)        elif y1 == y2:            if x2 > x1:                self.draw_rect(x1, y1, x2, y2+1, c)            else:                self.draw_rect(x2, y1, x1, y2+1, c)        else:            dp = self.draw_pixel            shortLen: int = y2-y1            longLen: int = x2-x1            if abs(shortLen) > abs(longLen):                swap: int = shortLen                shortLen = longLen                longLen = swap                yLonger: bool = True            else:                yLonger: bool = False            endVal: int = longLen            if longLen < 0:                incrementVal: int = -1                longLen = -1 * longLen            else:                incrementVal: int = 1            decInc = int(0)            if longLen > int(0):                decInc = int(self.__divide(shortLen << 16, longLen))            j: int = int(0)            if yLonger:                for i in range(0, endVal, incrementVal):                    dp(x1+(j >> 16), y1+int(i), c)                    j += decInc            else:                for i in range(0, endVal, incrementVal):                    dp(x1+int(i), y1+(j >> 16), c)                    j += decInc    @micropython.viper    def draw_text(self, x: int, y: int, c: int, text):        bma = bytearray(8)        p_bm = ptr8(bma)        for i in range(8):            p_bm[i] = 1 << i        tlen = int(0)        dp = self.draw_pixel        for t in text:            cb, length = glcdfont.get_ch(t)            p_cb = ptr8(cb)            for r in range(int(len(cb))):                for k in range(int(len(bma))):                    if p_cb[r] & p_bm[k]:                        dp(x+k, y+tlen+r, c)            tlen += int(length)    @micropython.viper    def clear(self, color: int = 0x0000):        self.draw_rect(0, 0, 240, 320, color)     